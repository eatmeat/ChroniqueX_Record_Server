<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Аудио-рекордер</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap');

        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 10px;
            background-color: #f0f2f5;
            color: #333;
        }

        .container {
            width: 95%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 5px;
        }

        .settings-container {
            background-color: #fff;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .recorder-container {
            background-color: #fff;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 100%;
            margin-bottom: 20px;
            box-sizing: border-box;
        }

        .settings-container {
            background-color: #fff;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .recordings-container {
            background-color: #fff;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            width: 100%;
            box-sizing: border-box;
        }

        h1 {
            margin-top: 0;
            font-weight: 700;
            color: #2c3e50;
            font-size: 1.5rem;
        }

        #status-container {
            margin-bottom: 20px;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        #post-process-container {
            margin-bottom: 15px;
            font-size: 14px;
            color: #2980b9; /* Blue color for post-processing status */
            padding: 8px;
            border-radius: 8px;
            background-color: #ecf0f1;
            min-height: 20px;
        }

        #status-light {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #95a5a6; /* Silver */
            transition: background-color 0.3s;
        }

        #status-light.recording {
            background-color: #e74c3c; /* Red */
            animation: pulse 1.5s infinite;
        }

        #timer {
            font-weight: 300;
            font-size: 20px;
            letter-spacing: 1px;
        }

        .buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .buttons button {
            font-size: 16px;
            padding: 10px 15px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            transition: background-color 0.3s, transform 0.2s;
            color: #fff;
            font-weight: 400;
            min-width: 80px;
            flex: 1;
            min-height: 40px;
        }

        #startButton {
            background-color: #27ae60; /* Green */
        }

        #startButton:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }

        #startButton:hover:not(:disabled) {
            background-color: #2ecc71;
            transform: translateY(-2px);
        }

        #pauseButton {
            background-color: #f39c12; /* Orange */
        }

        #pauseButton:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }

        #pauseButton:hover:not(:disabled) {
            background-color: #f1c40f;
            transform: translateY(-2px);
        }

        #stopButton {
            background-color: #c0392b; /* Red */
        }

        #stopButton:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }

        #stopButton:hover:not(:disabled) {
            background-color: #e74c3c;
            transform: translateY(-2px);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th, td {
            padding: 8px 6px;
            text-align: left;
            border-bottom: 1px solid #ddd;
            font-size: 14px;
            white-space: nowrap;
        }

        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }

        tr:hover {
            background-color: #f5f5f5;
        }

        .file-link {
            color: #3498db;
            text-decoration: none;
            word-break: break-word;
        }

        .file-link:hover {
            text-decoration: underline;
        }
        
        /* Container for table to enable horizontal scrolling when needed */
        .table-container {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            width: 100%;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .status-exists {
            background-color: #27ae60; /* Green */
        }

        .status-missing {
            background-color: #e74c3c; /* Red */
        }

        .date-group {
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }

        .group-header {
            background-color: #f8f9fa;
            padding: 12px;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
        }

        .group-header:hover {
            background-color: #e9ecef;
        }

        .group-header h3 {
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 16px;
            flex-wrap: wrap;
        }

        .expand-icon {
            font-size: 12px;
            transition: transform 0.2s;
        }

        .expanded .expand-icon {
            transform: rotate(90deg);
        }

        .group-content {
            padding: 0;
        }

        .recordings-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 100%;
        }

        .record-count {
            font-size: 0.85em;
            color: #6c757d;
        }
        
        .recreate-btn {
            margin-left: 10px;
            padding: 4px 8px;
            font-size: 12px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .recreate-btn:hover {
            background-color: #5a6268;
        }
        
        .compress-btn {
            margin-left: 10px;
            padding: 4px 8px;
            font-size: 12px;
            background-color: #17a2b8;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .compress-btn:hover {
            background-color: #138496;
        }

        .settings-container h2 {
            margin-top: 0;
            font-weight: 700;
            color: #2c3e50;
            font-size: 1.3rem;
            text-align: left;
            margin-bottom: 15px;
        }

        .setting-item {
            margin-bottom: 15px;
            text-align: left;
        }

        .setting-item label {
            display: block;
            margin-bottom: 5px;
            font-weight: 400;
        }
        .setting-item input[type="checkbox"] {
            margin-right: 8px;
        }
        .setting-item textarea {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            box-sizing: border-box;
            font-family: 'Roboto', sans-serif;
            font-size: 14px;
        }
        #saveSettingsButton {
            background-color: #3498db;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        #saveSettingsButton:hover {
            background-color: #2980b9;
        }

        #saveStatus {
            /* margin-top: 10px; */ /* Removed to allow flexbox to align vertically */
            margin-left: 15px; /* Add left margin for spacing */
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        
        .settings-actions {
            display: flex;
            align-items: center;
            margin-top: 10px; /* Add some space above the button and status */
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 20px; /* Adjust gap between checkbox items */
            align-items: center;
        }

        /* Mobile responsiveness */
        @media screen and (max-width: 768px) {
            .container {
                width: 98%;
                padding: 2px;
            }
            
            .recorder-container {
                padding: 15px;
            }
            
            h1 {
                font-size: 1.3rem;
            }
            
            #status-container {
                font-size: 14px;
                gap: 5px;
            }
            
            #timer {
                font-size: 18px;
            }
            
            .buttons {
                gap: 8px;
            }
            
            .buttons button {
                font-size: 14px;
                padding: 8px 10px;
                min-width: 70px;
                min-height: 36px;
            }
            
            .recordings-container {
                padding: 10px;
            }
            
            th, td {
                padding: 6px 4px;
                font-size: 13px;
            }
            
            .group-header {
                padding: 10px;
            }
            
            .group-header h3 {
                font-size: 14px;
            }
            
            #backToTop {
                bottom: 15px;
                right: 20px;
                padding: 12px;
                font-size: 16px;
            }
        }
        
        @media screen and (max-width: 480px) {
            body {
                padding: 5px;
            }
            
            .container {
                width: 100%;
                padding: 2px;
            }
            
            .recorder-container {
                padding: 12px;
            }
            
            h1 {
                font-size: 1.2rem;
            }
            
            #status-container {
                font-size: 13px;
                flex-direction: column;
                gap: 5px;
            }
            
            #timer {
                font-size: 16px;
            }
            
            .buttons {
                flex-direction: column;
                gap: 10px;
            }
            
            .buttons button {
                font-size: 16px;
                padding: 12px;
                min-height: 44px;
            }
            
            /* Make table cells more compact on very small screens */
            th, td {
                padding: 4px 2px;
                font-size: 11px;
            }
            
            .file-link {
                font-size: 11px;
            }
            
            .group-header h3 {
                font-size: 13px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .record-count {
                font-size: 0.8em;
            }
            
            /* Reduce table font size further on very small screens */
            .recordings-table {
                font-size: 10px;
                width: 100%;
            }
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(231, 76, 60, 0); }
            100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0); }
        }

        /* Custom Context Menu */
        .custom-context-menu {
            position: absolute;
            z-index: 1000;
            display: none;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            padding: 5px 0;
            font-family: 'Roboto', sans-serif;
        }

        .context-menu-item {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
            color: #333;
        }

        .context-menu-item:hover {
            background-color: #f0f2f5;
        }

        .context-menu-separator {
            height: 1px;
            background-color: #eee;
            margin: 4px 0;
        }




    </style>
</head>
<body>
    <div class="container">
        <div class="recorder-container">
            <h1>Аудио-рекордер</h1>
            <div id="status-container">
                <div id="status-light"></div>
                <div id="status">Ожидание</div>
            </div>
            <div id="post-process-container">
                Постобработка: не выполняется
            </div>
            <div id="timer">00:00:00</div>
            <div class="buttons">
                <button id="startButton">Старт</button>
                <button id="pauseButton" disabled>Пауза</button>
                <button id="stopButton" disabled>Стоп</button>
            </div>
        </div>

        <div class="settings-container">
            <h2>Настройки постобработки</h2>
            <div class="setting-item">
                <div class="checkbox-group">
                    <input type="checkbox" id="useCustomPrompt" name="use_custom_prompt" {% if use_custom_prompt %}checked{% endif %}>
                    <label for="useCustomPrompt">Использовать дополнение к промпту</label>
                    <input type="checkbox" id="includeHtmlFiles" name="include_html_files" {% if include_html_files %}checked{% endif %}>
                    <label for="includeHtmlFiles">Добавлять HTML файлы в контекст</label>
                </div>
            </div>
            <div class="setting-item">
                <label for="promptAddition">Дополнение к промпту:</label>
                <textarea id="promptAddition" name="prompt_addition" rows="8">{{ prompt_addition }}</textarea>
            </div>
            <div class="settings-actions">
                <button id="saveSettingsButton">Применить настройки</button>
                <div id="saveStatus"></div>
            </div>
        </div>

        <div class="recordings-container">
            <h2>Записи, транскрипции и протоколы</h2>
            {% if date_groups %}
                {% for group in date_groups %}
                <div class="date-group">
                    <div class="group-header" onclick="toggleGroup('{{ group.date }}')">
                        <h3>
                            <span class="expand-icon" id="icon-{{ group.date }}">▶</span>
                            {{ group.formatted_date }} ({{ group.day_of_week }})
                            <span class="record-count">количество: {{ group.recordings|length }}</span>
                        </h3>
                    </div>
                    <div class="group-content" id="content-{{ group.date }}" style="display: none;">
                        <div class="table-container">
                            <table class="recordings-table">
                                <thead>
                                    <tr>
                                        <th>Время</th>
                                        <th>Аудиозапись</th>
                                        <th>Транскрипция</th>
                                        <th>Протокол</th>
                                        <th>Размер</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {% for recording in group.recordings %}
                                    <tr>
                                        <td>{{ recording.time }}</td>
                                        <td>
                                            <span class="status-indicator status-exists"></span>
                                            <a href="/files/{{ recording.date }}/{{ recording.filename }}" class="file-link">{{ recording.filename }}</a>
                                            {% if recording.filename.endswith('.wav') %}
                                            <button class="compress-btn" onclick="compressToMp3('{{ recording.date }}', '{{ recording.filename }}')">Сжать в MP3</button>
                                            {% endif %}
                                        </td>
                                        <td>
                                            {% if recording.transcription_exists %}
                                            <span class="status-indicator status-exists"></span>
                                            <a href="/files/{{ recording.date }}/{{ recording.transcription_filename }}" class="file-link">{{ recording.transcription_filename }}</a>
                                            <button class="recreate-btn" onclick="recreateTranscription('{{ recording.date }}', '{{ recording.filename }}')">Пересоздать</button>
                                            {% else %}
                                            <span class="status-indicator status-missing"></span>
                                            Отсутствует
                                            <button class="recreate-btn" onclick="recreateTranscription('{{ recording.date }}', '{{ recording.filename }}')">Создать</button>
                                            {% endif %}
                                        </td>
                                        <td>
                                            {% if recording.protocol_exists %}
                                            <span class="status-indicator status-exists"></span>
                                            <a href="/files/{{ recording.date }}/{{ recording.protocol_filename }}" class="file-link">{{ recording.protocol_filename }}</a>
                                            <button class="recreate-btn" onclick="recreateProtocol('{{ recording.date }}', '{{ recording.filename }}')">Пересоздать</button>
                                            {% else %}
                                            <span class="status-indicator status-missing"></span>
                                            Отсутствует
                                            <button class="recreate-btn" onclick="recreateProtocol('{{ recording.date }}', '{{ recording.filename }}')">Создать</button>
                                            {% endif %}
                                        </td>
                                        <td>{{ "%.2f"|format(recording.size / 1024 / 1024) }} МБ</td>
                                    </tr>
                                    {% endfor %}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
                {% endfor %}
            {% else %}
            <p>Записей пока нет. После создания записей они появятся здесь.</p>
            {% endif %}
        </div>
    </div>

    <!-- Custom Context Menu for Textarea -->
    <div id="textareaContextMenu" class="custom-context-menu">
        <div class="context-menu-item" data-action="cut">Вырезать</div>
        <div class="context-menu-item" data-action="copy">Копировать</div>
        <div class="context-menu-item" data-action="paste">Вставить</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="selectAll">Выделить всё</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="comment">Закомментировать</div>
        <div class="context-menu-item" data-action="uncomment">Раскомментировать</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="clear">Очистить</div>
    </div>

    <!-- Back to Top Button -->
    <button onclick="topFunction()" id="backToTop" title="Go to top" style="
        display: none;
        position: fixed;
        bottom: 20px;
        right: 30px;
        z-index: 99;
        border: none;
        outline: none;
        background-color: #5a6268;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 10px;
        font-size: 18px;
    ">↑</button>

    <script>
        const startButton = document.getElementById('startButton');
        const pauseButton = document.getElementById('pauseButton');
        const stopButton = document.getElementById('stopButton');
        const statusDiv = document.getElementById('status');
        const statusLight = document.getElementById('status-light');
        const timerDiv = document.getElementById('timer');
        const postProcessDiv = document.getElementById('post-process-container');
        const saveSettingsButton = document.getElementById('saveSettingsButton');
        const useCustomPromptCheckbox = document.getElementById('useCustomPrompt');
        const includeHtmlFilesCheckbox = document.getElementById('includeHtmlFiles');
        const promptAdditionTextarea = document.getElementById('promptAddition');
        const saveStatusDiv = document.getElementById('saveStatus');
        const contextMenu = document.getElementById('textareaContextMenu');


        let statusInterval;

        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
            const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
            const s = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${h}:${m}:${s}`;
        }

        async function updateStatus() {
            try {
                const response = await fetch('/status');
                const data = await response.json();

                // Store previous status for comparison (but don't auto-refresh to avoid infinite loop)
                const previousStatus = statusDiv.textContent;
                const previousPostProcessInfo = postProcessDiv.textContent;
                
                if (data.status === 'rec') {
                    const timeParts = data.time.split(':').map(Number);
                    const seconds = timeParts[0] * 3600 + timeParts[1] * 60 + timeParts[2];

                    timerDiv.textContent = formatTime(seconds);
                    statusDiv.textContent = 'Запись';
                    statusLight.classList.add('recording');
                    startButton.disabled = true;
                    startButton.textContent = 'Старт'; // Reset text to default
                    pauseButton.disabled = false;
                    pauseButton.textContent = 'Пауза';
                    stopButton.disabled = false;

                    if (!statusInterval) {
                         statusInterval = setInterval(updateStatus, 1000);
                    }
                } else if (data.status === 'paused') {
                    const timeParts = data.time.split(':').map(Number);
                    const seconds = timeParts[0] * 3600 + timeParts[1] * 60 + timeParts[2];

                    timerDiv.textContent = formatTime(seconds);
                    statusDiv.textContent = 'Пауза';
                    statusLight.classList.remove('recording');
                    startButton.disabled = false;
                    startButton.textContent = 'Продолжить'; // Change text to indicate resume
                    pauseButton.disabled = true;
                    pauseButton.textContent = 'Пауза';
                    stopButton.disabled = false;
                } else {
                    timerDiv.textContent = '00:00:00';
                    statusDiv.textContent = 'Ожидание';
                    statusLight.classList.remove('recording');
                    startButton.disabled = false;
                    startButton.textContent = 'Старт'; // Reset text to default
                    pauseButton.disabled = true;
                    pauseButton.textContent = 'Пауза';
                    stopButton.disabled = true;
                    if (statusInterval) {
                        clearInterval(statusInterval);
                        statusInterval = null;
                    }
                }

                // Update post-processing status
                if (data.post_processing) {
                    postProcessDiv.textContent = data.post_processing.info;
                    if (data.post_processing.active) {
                        postProcessDiv.style.backgroundColor = '#d6eaf8'; // Light blue when active
                    } else {
                        postProcessDiv.style.backgroundColor = '#ecf0f1'; // Light gray when inactive
                    }
                } else {
                    postProcessDiv.textContent = 'Постобработка: не выполняется';
                    postProcessDiv.style.backgroundColor = '#ecf0f1';
                }
                
                // Don't automatically refresh on status change to avoid infinite loop
                // Recordings will be refreshed manually or after specific operations
            } catch (error) {
                console.error('Ошибка обновления статуса:', error);
                statusDiv.textContent = 'Ошибка';
                statusLight.classList.remove('recording');
                postProcessDiv.textContent = 'Ошибка получения статуса постобработки';
                if (statusInterval) {
                    clearInterval(statusInterval);
                    statusInterval = null;
                }
            }
        }

        startButton.addEventListener('click', async () => {
            try {
                const response = await fetch('/rec');
                const data = await response.json();
                if (data.status === 'ok') {
                    // Добавляем небольшую задержку, чтобы сервер успел обновить состояние
                    setTimeout(() => updateStatus(), 200);
                    // Не обновляем список записей сразу, ждем остановки
                } else {
                    alert(`Ошибка: ${data.error}`);
                }
            } catch (error) {
                console.error('Ошибка начала записи:', error);
                alert('Ошибка начала записи.');
            }
        });

        pauseButton.addEventListener('click', async () => {
            try {
                const response = await fetch('/pause');
                const data = await response.json();
                if (data.status === 'ok') {
                    // Добавляем небольшую задержку, чтобы сервер успел обновить состояние
                    setTimeout(() => updateStatus(), 200);
                    // Не обновляем список записей
                } else {
                    alert(`Ошибка: ${data.error}`);
                }
            } catch (error) {
                console.error('Ошибка паузы записи:', error);
                alert('Ошибка паузы записи.');
            }
        });

        stopButton.addEventListener('click', async () => {
            try {
                const response = await fetch('/stop');
                const data = await response.json();
                if (data.status === 'ok') {
                   // Добавляем небольшую задержку, чтобы сервер успел обновить состояние
                   setTimeout(updateStatus, 200);
                   setTimeout(() => refreshRecordings(), 2000); // Обновляем список записей с задержкой, чтобы файл успел появиться
                } else {
                    alert(`Ошибка: ${data.error}`);
                }
            } catch (error) {
                console.error('Ошибка остановки записи:', error);
                alert('Ошибка остановки записи.');
            }
        });

        saveSettingsButton.addEventListener('click', async () => {
            const settings = {
                use_custom_prompt: useCustomPromptCheckbox.checked,
                include_html_files: includeHtmlFilesCheckbox.checked,
                prompt_addition: promptAdditionTextarea.value
            };

            try {
                const response = await fetch('/save_web_settings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(settings),
                });
                const data = await response.json();

                saveStatusDiv.textContent = data.message;
                if (response.ok) {
                    saveStatusDiv.style.color = 'green';
                    saveStatusDiv.style.backgroundColor = '#e8f5e9';
                } else {
                    saveStatusDiv.style.color = 'red';
                    saveStatusDiv.style.backgroundColor = '#fce4e4';
                }
                saveStatusDiv.style.display = 'block';
                setTimeout(() => { saveStatusDiv.style.display = 'none'; }, 5000);

            } catch (error) {
                console.error('Ошибка сохранения настроек:', error);
                alert('Произошла ошибка при сохранении настроек.');
            }
        });

        // Function to toggle group visibility
        function toggleGroup(groupId) {
            const content = document.getElementById('content-' + groupId);
            const icon = document.getElementById('icon-' + groupId);
            const header = content.previousElementSibling;
            
            if (content.style.display === 'none' || content.style.display === '') {
                content.style.display = 'block';
                header.classList.add('expanded');
            } else {
                content.style.display = 'none';
                header.classList.remove('expanded');
            }
        }

        // Function to refresh recordings list while preserving expand/collapse state
        async function refreshRecordings() {
            try {
                // Get the IDs of currently expanded groups
                const expandedGroups = [];
                const allGroups = document.querySelectorAll('.date-group');
                allGroups.forEach(group => {
                    const groupId = group.querySelector('.group-header').getAttribute('onclick').match(/toggleGroup\('([^']+)'\)/)[1];
                    const content = document.getElementById('content-' + groupId);
                    if (content && content.style.display !== 'none') {
                        expandedGroups.push(groupId);
                    }
                });
                
                const response = await fetch('/');
                const htmlText = await response.text();
                
                // Parse the new HTML to extract the recordings container
                const parser = new DOMParser();
                const newDoc = parser.parseFromString(htmlText, 'text/html');
                const newRecordingsContainer = newDoc.querySelector('.recordings-container');
                
                if (newRecordingsContainer) {
                    const currentRecordingsContainer = document.querySelector('.recordings-container');
                    currentRecordingsContainer.innerHTML = newRecordingsContainer.innerHTML;
                    
                    // Reattach event listeners for the new elements
                    attachEventListeners();
                    
                    // Restore the expanded state of groups that were previously expanded
                    expandedGroups.forEach(groupId => {
                        const content = document.getElementById('content-' + groupId);
                        const icon = document.getElementById('icon-' + groupId);
                        const header = document.querySelector(`.group-header[onclick*="${groupId}"]`);
                        
                        if (content && icon && header) {
                            content.style.display = 'block';
                            header.classList.add('expanded');
                        }
                    });
                }
            } catch (error) {
                console.error('Error refreshing recordings:', error);
            }
        }

        // Function to attach event listeners to dynamically loaded elements
        function attachEventListeners() {
            // Reattach toggleGroup functionality to new elements
            const groupHeaders = document.querySelectorAll('.group-header');
            groupHeaders.forEach(header => {
                // Get the groupId from the onclick attribute
                const match = header.getAttribute('onclick').match(/toggleGroup\('([^']+)'\)/);
                if (match) {
                    const groupId = match[1];
                    // Remove the old onclick handler and add a new one
                    header.onclick = (e) => {
                        e.preventDefault();
                        toggleGroup(groupId);
                    };
                }
            });
        }

        // Add "Back to Top" button functionality
        window.onscroll = function() {
            scrollFunction();
        };

        function scrollFunction() {
            const backToTopBtn = document.getElementById("backToTop");
            
            if (document.body.scrollTop > 100 || document.documentElement.scrollTop > 100) {
                backToTopBtn.style.display = "block";
            } else {
                backToTopBtn.style.display = "none";
            }
        }

        function topFunction() {
            document.body.scrollTop = 0; // For Safari
            document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
        }
        
        // Functions to recreate transcription and protocol
        async function recreateTranscription(date, filename) {
            if (!confirm(`Вы уверены, что хотите пересоздать транскрипцию для файла ${filename}?`)) {
                return;
            }
            
            try {
                const response = await fetch(`/recreate_transcription/${date}/${filename}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    // Refresh the recordings list to show the updated status
                    setTimeout(() => refreshRecordings(), 1000); // Refresh recordings after a delay
                } else {
                    const errorText = await response.text();
                    alert(`Ошибка при пересоздании транскрипции: ${errorText}`);
                }
            } catch (error) {
                alert(`Ошибка при запросе пересоздания транскрипции: ${error.message}`);
            }
        }
        
        async function recreateProtocol(date, filename) {
            if (!confirm(`Вы уверены, что хотите пересоздать протокол для файла ${filename}?`)) {
                return;
            }
            
            try {
                const response = await fetch(`/recreate_protocol/${date}/${filename}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    // Refresh the recordings list to show the updated status
                    setTimeout(() => refreshRecordings(), 1000); // Refresh recordings after a delay
                } else {
                    const errorText = await response.text();
                    alert(`Ошибка при пересоздании протокола: ${errorText}`);
                }
            } catch (error) {
                alert(`Ошибка при запросе пересоздания протокола: ${error.message}`);
            }
        }

        async function compressToMp3(date, filename) {
            if (!confirm(`Вы уверены, что хотите сжать файл ${filename} в формат MP3?`)) {
                return;
            }

            try {
                const response = await fetch(`/compress_to_mp3/${date}/${filename}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    // Refresh the recordings list to show the updated status
                    setTimeout(() => refreshRecordings(), 1000); // Refresh recordings after a delay
                } else {
                    const errorText = await response.text();
                    alert(`Ошибка при сжатии в MP3: ${errorText}`);
                }
            } catch (error) {
                alert(`Ошибка при запросе сжатия в MP3: ${error.message}`);
            }
        }

        // --- Textarea Context Menu Logic ---

        promptAdditionTextarea.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            contextMenu.style.top = `${e.pageY}px`;
            contextMenu.style.left = `${e.pageX}px`;
            contextMenu.style.display = 'block';
        });

        document.addEventListener('click', (e) => {
            if (!contextMenu.contains(e.target)) {
                contextMenu.style.display = 'none';
            }
        });

        contextMenu.addEventListener('click', (e) => {
            const action = e.target.dataset.action;
            if (action) {
                executeContextMenuAction(action);
                contextMenu.style.display = 'none';
            }
        });

        function executeContextMenuAction(action) {
            const textarea = promptAdditionTextarea;
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;

            switch (action) {
                case 'cut':
                    document.execCommand('cut');
                    break;
                case 'copy':
                    document.execCommand('copy');
                    break;
                case 'paste':
                    navigator.clipboard.readText().then(text => {
                        const currentText = textarea.value;
                        const newText = currentText.substring(0, start) + text + currentText.substring(end);
                        textarea.value = newText;
                        textarea.selectionStart = textarea.selectionEnd = start + text.length;
                    }).catch(err => console.error('Failed to read clipboard contents: ', err));
                    break;
                case 'selectAll':
                    textarea.select();
                    break;
                case 'comment':
                case 'uncomment':
                    modifyLines(textarea, action);
                    break;
                case 'clear':
                    textarea.value = '';
                    break;
            }
        }

        function modifyLines(textarea, action) {
            const text = textarea.value;
            let selStart = textarea.selectionStart;
            let selEnd = textarea.selectionEnd;

            // Find the start of the first selected line
            let lineStart = text.lastIndexOf('\n', selStart - 1) + 1;

            // Find the end of the last selected line
            let lineEnd = text.indexOf('\n', selEnd);
            if (lineEnd === -1) {
                lineEnd = text.length;
            }
            // If selection ends exactly at a newline, don't include the next line
            if (selEnd > 0 && text[selEnd - 1] === '\n') {
                lineEnd = selEnd -1;
            }

            const selectedLinesText = text.substring(lineStart, lineEnd);
            const lines = selectedLinesText.split('\n');
            let modifiedLinesText = '';
            let lengthChange = 0;

            if (action === 'comment') {
                modifiedLinesText = lines.map(line => {
                    if (line.trim() !== '') { // Don't comment empty lines
                        lengthChange += 2;
                        return '//' + line;
                    }
                    return line;
                }).join('\n');
            } else { // uncomment
                modifiedLinesText = lines.map(line => {
                    if (line.trim().startsWith('//')) {
                        lengthChange -= 2;
                        return line.replace('//', '');
                    }
                    return line;
                }).join('\n');
            }

            // Replace the original lines with the modified ones
            const newText = text.substring(0, lineStart) + modifiedLinesText + text.substring(lineEnd);
            textarea.value = newText;

            // Restore selection
            textarea.selectionStart = selStart;
            textarea.selectionEnd = selEnd + lengthChange;
            textarea.focus();
        }

        // Add keyboard shortcuts for comment/uncomment (Ctrl + /)
        promptAdditionTextarea.addEventListener('keydown', function(e) {
            // Ctrl + / for comment/uncomment
            if (e.ctrlKey && e.key === '/') {
                e.preventDefault();
                modifyLines(this, 'comment'); // Or toggle logic could be added here
            }
        });

        // Initial status check
        updateStatus();
        // Fallback polling to sync state if things get out of sync
        setInterval(updateStatus, 5000);
        // Periodically refresh recordings list to show updates
        setInterval(refreshRecordings, 10000); // Refresh recordings every 10 seconds
    </script>
</body>
</html>